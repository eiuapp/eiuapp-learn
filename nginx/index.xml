<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nginx on Documentation for Hugo Learn Theme</title>
    <link>https://eiuapp.github.io/eiuapp-learn/nginx.html</link>
    <description>Recent content in nginx on Documentation for Hugo Learn Theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 27 Jun 2019 15:15:15 +0800</lastBuildDate>
    
	<atom:link href="https://eiuapp.github.io/eiuapp-learn/nginx/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nginx Servername</title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-servername.html</link>
      <pubDate>Mon, 25 Jun 2018 14:13:09 +0800</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-servername.html</guid>
      <description>nginx中servername的作用
Env  os: ubuntu16 外网ip: 13.209.68.247 domain name: link.devs1.xsl.ph  Step 当配置了servername后，只能通过 servername 访问被代理URL
看配置
root@ip-172-31-21-164:/etc/nginx/sites-enabled# cat links server{ listen 80; server_name link.devs1.xsl.ph; client_max_body_size 80m; location /spider { proxy_pass http://127.0.0.1:9003/spider; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; } } root@ip-172-31-21-164:/etc/nginx/sites-enabled# /etc/init.d/nginx restart [ ok ] Restarting nginx (via systemctl): nginx.service root@ip-172-31-21-164:/etc/nginx/sites-enabled#  请求
root@ip-172-31-21-164:/etc/nginx/sites-enabled# curl link.devs1.xsl.ph/spider/news/hello hello,null.server.port==9003spring.profiles.active==testspring.datasource.url==jdbc:mysql://localhost:3306/link?useUnicode=true&amp;amp;characterEncoding=utf-8 root@ip-172-31-21-164:/etc/nginx/sites-enabled#  但是通过其它都不行。127.0.0.1,localhost,外网IP13.209.68.247都不可以的。都会返回404错误。
root@ip-172-31-21-164:/etc/nginx/sites-enabled# curl 13.209.68.247/spider/news/hello &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;404 Not Found&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body bgcolor=&amp;quot;white&amp;quot;&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;404 Not Found&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.</description>
    </item>
    
    <item>
      <title>Nginx Config Server_name</title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-config-server_name.html</link>
      <pubDate>Tue, 12 Jun 2018 18:11:31 +0800</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-config-server_name.html</guid>
      <description>nginx 配合 godaddy 完成 3级域名
原理：godaddy, 配置3级域名解析，转到nginx配置中的 server_name
Env  os: ubuntu16 nginx: nginx/1.10.3 (Ubuntu) 2级域名: bitzone.space 3级域名: store1.bitzone.space godaddy  Step 配置nginx 在 nginx 的 sites-enabled 中配置
root@ip-172-31-28-68:~# cat sites-enabled/store1 server { listen 80; server_name store1.bitzone.space; client_max_body_size 80m; location / { index index.html; root /home/ubuntu/html/code_commit_vac_competition/APP; #root /home/dev/completition/code_commit_competition/code_commit_competition_food_blockChainCheck; } }  配置godaddy 打开相应地址(2级域名: bitzone.space)的DNS管理
增加
A	store1	52.78.79.111	600 秒  确认 浏览器访问http://store1.bitzone.space/index.html 就访问到了 http://52.78.79.111:80 , 根据nginx配置就知道， 拿到了 52.78.79.111:/home/ubuntu/html/code_commit_vac_competition/APP/index.html这里的资源</description>
    </item>
    
    <item>
      <title>Nginx Faq 2</title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-faq-2.html</link>
      <pubDate>Fri, 02 Mar 2018 15:04:12 +0800</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-faq-2.html</guid>
      <description> nginx txt,json文件 中文乱码
nginx 中 txt,json文件 中文乱码 在 /etc/nginx/conf.d/default.conf 中找到 location / { ,然后加入
charset utf-8; charset_types text/html  如：
server { listen 8000; server_name localhost; #default_type &#39;text/html&#39;; #charset utf-8; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { charset utf-8; charset_types text/html application/json; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;  </description>
    </item>
    
    <item>
      <title>Nginx Faq 1</title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-faq-1.html</link>
      <pubDate>Fri, 02 Mar 2018 15:03:32 +0800</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-faq-1.html</guid>
      <description>nginx 跨域访问
 nginx 解决跨域访问的问题 跨域造成session丢失  nginx 解决跨域访问的问题。 https://michielkalkman.com/snippets/nginx-cors-open-configuration.html
http://enable-cors.org/server_nginx.html
 所有网页都实现跨域  把下面的代码，放到 ，配置文件 /etc/nginx/conf.d/default.conf 中的 location / { 内
add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;   部分url（下以 /ok 为例） 请求实现跨域访问  把下面的代码，放到 ，配置文件 /etc/nginx/conf.d/default.conf 中 的 location /ok { 内
# # Wide-open CORS config for nginx # location / { if ($request_method = &#39;OPTIONS&#39;) { add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; # # Om nom nom cookies # add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;; # # Custom headers and headers various browsers *should* be OK with but aren&#39;t # add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;; # # Tell client that this pre-flight info is valid for 20 days # add_header &#39;Access-Control-Max-Age&#39; 1728000; add_header &#39;Content-Type&#39; &#39;text/plain charset=UTF-8&#39;; add_header &#39;Content-Length&#39; 0; return 204; } if ($request_method = &#39;POST&#39;) { add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;; add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;; } if ($request_method = &#39;GET&#39;) { add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;; add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;; } }  跨域造成session丢失 https://segmentfault.</description>
    </item>
    
    <item>
      <title>Nginx Seo</title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-seo.html</link>
      <pubDate>Tue, 27 Feb 2018 11:08:59 +0800</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-seo.html</guid>
      <description> seo 优化去掉html 页面的后缀 .html ubuntu@VM-0-12-ubuntu:/etc/nginx/conf.d$ cat 8766.conf server { listen 8766; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; # seo 优化去掉html 页面的后缀 .html if (!-f $request_filename){ set $rule_0 1$rule_0; } if ($rule_0 = &amp;quot;1&amp;quot;){ rewrite ^/([^\.]+)$ /$1.html last; } location / { root /home/ubuntu/registry/tomtsang-rootsongjc-cheatsheet/_site; index index.html index.htm; # proxy_pass http://127.0.0.1:4001; } ...  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-bug-fix.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-bug-fix.html</guid>
      <description>记一次nginx的漏洞补救
env 安全报告中提示 nginx 安全漏洞（CVE-2018-16843） ,百度，nginx CVE-2018-16843
 nginx:  version: 1.13.0 directory:  源码： /usr/svc/nginx-1.13.0 编译后：/opt/local/nginx   os: solaris10  step 找版本 https://cloud.tencent.com/info/71abe1e1ae97740ce376d8b46f894dbd.html
提示，要升级到 1.14.1 。去 github.com 查一下 nginx的releases.
https://github.com/nginx/nginx/releases
果然，
on 6 Nov 2018 release-1.14.1  那我们快速安装 1.14.1 或以上版本吧。
不编译 试图躲过编译安装
因为是 solaris10, 机器上，没有 c 编译器，所以，看能不能躲过编译安装
https://www.opencsw.org/packages/CSWnginx/
pkgadd -d http://get.opencsw.org/now /opt/csw/bin/pkgutil -U /opt/csw/bin/pkgutil -i nginx /opt/csw/bin/pkgutil -y -i nginx /usr/sbin/pkgchk -L CSWnginx # list files  /opt/csw/bin/pkgutil -i nginx 是为了查看版本号，看是不是我们想要的版本，如果不是，则不安装。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-fix-diff-path-diff-cookie-path.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx-fix-diff-path-diff-cookie-path.html</guid>
      <description>解决同域名不同路径下形成不同session cookie, 从而使得不同的帐户密码登录
targit 我的最终目的是要让
 http://192.168.168.137:8081/ 使用 一个帐号密码(admin:adminsz189)登录 http://192.168.168.137:8081/admin/ 使用 另一个帐号密码(admin:admin)登录  env 参考 解决nginx proxy_pass反向代理cookie,session丢失的问题
为什么cookie 会丢失？ 比如说一个没有经过代理的地址 ： http://127.0.0.1/project cookie_path：/project
如果按照第二种方式代理 那么地址就是 ： http://127.0.0.1/proxy_path cookie_path: /proxy_path
如果cookie_path与地址栏上的path不相符游览器就不会接受这个cookie，自然session就失效了
proxy_cookie_path 的用法 proxy_cookie_path 的作用是用来改变cookie的路径
语法： proxy_cookie_path path replacement; path就是你要替换的路径 replacement 就是要替换的值
详情可以去nginx 官网看看 传送门
下面是可能的三种情况
 host、端口转换，cookie不会丢失   location /project { proxy_pass http://127.0.0.1:8080/project; }   路径也变化，则需要设置cookie的路径转换   location /proxy_path { proxy_pass http://127.0.0.1:8080/project; proxy_cookie_path /project /proxy_path; }   直接代理本地端口   location /proxy_path { proxy_pass http://127.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/nginx.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/nginx.html</guid>
      <description>nginx</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/Rewrite.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/Rewrite.html</guid>
      <description>Rewrite [TOC]
Upstream命令-负载 upstream upstream name {...} ;  name为服务器组的组名（别名），花括号中可以列出后端服务器组中包含的服务器
默认轮询（Round-Robin），轮流处理请求，如果某个服务器处理时出现错误，则切换下一个服务器，直到所有服务器报错，返回报错内容
server server address [patameters];   address，服务器地址，可以是IP地址，主机名，域名，或者unix Domain Socket  parameters  weight=number，服务器权重，权重值高的优先处理请求 max_fails=number，设置请求失败次数，一定时间范围，服务器请求失败的次数搞过限定值，认为服务器down，默认值为1，设置为0则失效 fail_timeout，设置尝试请求某服务器的时间，即max_fails的事件范围。也用于检查服务器时候有效，如果一台服务器down，则该时间段内不会再次检查服务器状态；默认10Ss backup,标记某个服务器为备用服务器，只有其他服务器down或者busy时才处理客户端请求 down，永久标记服务器为无效，通常与ip_hash配合使用   配置示例：
upstream backend { server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; }  ip_hash 基于IP地址将客户端的请求定向到同一台服务器，保证客户端与服务器间会话稳定
局限：
 不能用server中的weight变量一起使用 nginx服务器必须是最前端的服务器，才能获取到客户端真实IP 客户端IP地址必须是C类地址  upstream backend { ip_hash; server myback1.proxy.com; server myback2.proxy.com; }  keepalive keepalive connections;  connections为nginx服务器每个worker process允许该服务器组保持的空闲网络连接数上线，超过后哦，将采用最近最少使用的策略关闭网络连接</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/gzip%E5%8E%8B%E7%BC%A9.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/gzip%E5%8E%8B%E7%BC%A9.html</guid>
      <description>gzip压缩 gzip压缩页面需要浏览器和服务器双方支持，即服务器端压缩，浏览器端解压并解析。压缩页面后，传输流量小，传输速度更快
我的配置如下，压缩效果很明显：
gzip on; gzip_comp_level 9; gzip_min_length 1024; gzip_types text/plain application/javascript text/css application/xml application/json;  查看header信息中Content-Encoding: gzip
$ curl -I -H &amp;quot;Accept-Encoding: gzip, deflate&amp;quot; https://huangwj.app/search_index.json % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0HTTP/1.1 200 OK Server: nginx/1.12.2 Date: Tue, 12 Jun 2018 06:28:11 GMT Content-Type: application/json Last-Modified: Mon, 11 Jun 2018 09:24:44 GMT Connection: keep-alive ETag: W/&amp;quot;5b1e3fdc-a2cf6&amp;quot; Content-Encoding: gzip  压缩效果很nice，压缩前search_index.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E5%9F%BA%E7%A1%80.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E5%9F%BA%E7%A1%80.html</guid>
      <description>nginx基础 nginx官网：http://www.nginx.org
nginx wiki：https://www.nginx.com/resources/wiki/
nginx配置文件 nginx.conf示例 # 全局块：默认配置文件到event块之间的内容，主要设置一些影响nginx服务器整体运行的配置命令，包括nginx的用户，用户组，允许生成的worker process数，nginx进程PID存放路径，日志存放路径和类型、配置文件引入 user nobody;	# 用户nobody worker_processes 1;	# error_log logs/error.log; error_log logs/error.log notice; error_log logs/error.log info; pid logs/nginx.pid; # events块：events块涉及的指令主要影响nginx服务器与用户的网络连接，常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同事接受多个网络连接，怄那种时间驱动模型处理连接请求，每个worker process可以同事支持的最大连接数等 events { worker_connections 1024; } # http块是nginx服务器配置中的重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个模块中。 # http块中可以包含自己的全局快，也可以包含server块，server块中又可以金亦波包含location块，在本书中我们使用&amp;quot;http全局块&amp;quot;来表示http中自己的全局块，即http块中不包含在server块中的部分 # http全局块中可以包含文件引入、MIME-Type定义、日志自定义、是否使用sendfile传输文件、连接超时时间、单连接请求数上限等 http { include mime.types; default_type application/octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39; &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39; &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;; access_log logs/access.log main; sendfile on; tcp_nopush on; keepalive_timeout 0; keepalive_timeout 65; gzip on; # server块与虚拟主机的概念有密切联系。 # 虚拟主机，又称虚拟服务器、主机空间或者网页空间，他是一种技术，为了节互联网服务器硬件成本而出现。将服务内容逻辑划分为多个服务单位，对外表现为多个服务器，充分利用服务器硬件资源 # server块可以包含多个server块，而每个server块就相当于一台虚拟主机，他内部可有多台主机联合提供服务 server { listen 80; server_name localhost; charset koi8-r; access_log logs/host.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2.html</guid>
      <description>nginx服务器架构初探 模块化结构  核心模块：进程管理、权限控制、错误日志记录 标准HTTP模块：支持NGINX服务器标准HTTP功能 可选HTTP模块：扩展标准的HTTP功能，使其能够处理一些特殊的HTTP请求 邮件服务模块：支持NGINX的邮件服务 第三方模块：扩展NGINX服务器应用  核心模块和标准HTTP模块在NGINX快速编译后就包含在NGINX中
查看NGINX源码包
[root@test nginx-1.14.0]# ll objs/ total 3724 -rw-r--r-- 1 root root 19575 May 22 11:41 autoconf.err -rw-r--r-- 1 root root 39268 May 22 11:41 Makefile -rwxr-xr-x 1 root root 3679067 May 22 11:41 nginx -rw-r--r-- 1 root root 5321 May 22 11:41 nginx.8 -rw-r--r-- 1 root root 6598 May 22 11:41 ngx_auto_config.h -rw-r--r-- 1 root root 657 May 22 11:41 ngx_auto_headers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.html</guid>
      <description>nginx服务器的高级配置 /etc/sysctl.conf  针对IPv4的内核优化 net.core.netdev_max_backlog 队列数据包最大数目，表示每个网络接口接收数据报的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目
系统默认值128，NGINX服务器中定义的NGX_LISTEN_BACKLOG默认为511，需要调整参数
net.core.netdev_max_backlog = 262144  net.core.somaxconn 系统同时发起的TCP连接数，默认值128，可能导致链接超时或者重传问题，可以根据实际需要结合并发请求书来调节
net.core.somaxconn = 262144  net.ipv4.tcp_max_orphans 设置系统中最多允许存在多少TCP套接字不被关联到任何一个用户文件句柄，超过这个数字，米有与用户文件句柄关联的TCP套接字将被立即复位，同时给出警告信息
net.ipv4.tcp_max_orphans = 262144  net.ipv4.tcp_max_syn_backlog 未收到客户端确认信息的连接请求的最大值。大于128MB内存的系统默认值为1024，小内存则是128。可以增大该参数：
net.ipv4.tcp_max_syn_backlog = 262144  net.ipv4.tcp_timestamps 用于设置时间戳，避免序列号的卷绕。赋值为0时表示禁止TCP时间戳的支持。
net.ipv4.tcp_timestamps = 0  net.ipv4.tcp_synack_retries 用于内核放弃TCP连接之前向客户端发送SYN+ACK包的数量。服务器与客户端要通过三次握手建立连接，在第二次握手期间，内核需要发送SYN并附带一个回应前一个SYN的ACK，主要影响这里，建议赋值为1，即内核放弃连接之前发送一次SYN+ACK包：
net.ipv4.tcp_synack_retries = 1  net.ipv4.tcp_syn_retries 与net.ipv4.tcp_synack_retries类似，设置内核放弃建立连接之前发送SYN包的数量，建议1
net.ipv4.tcp_syn_retries = 1  针对CPU的配置优化 worker proceses  用来设置nginx服务的进程数，一般设置为CPU的倍数，我这里配置worker process auto，一个4个CPU线程，会起4个nginx进程
[root@test nginx]# ps -ef | grep nginx | grep -v grep root 1425 1 0 May22 ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E7%BC%93%E5%AD%98.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/nginx%E7%BC%93%E5%AD%98.html</guid>
      <description> nginx缓存 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/notes.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/notes.html</guid>
      <description>nginx学习笔记 参考苗泽nginx高性能web服务器详解，记录学习过程</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/notes/proxy.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/notes/proxy.html</guid>
      <description>proxy 反向代理常用命令 proxy_pass  server { location / { proxy_pass http://1.1.1.1:8080; } }  upstream时关于http协议的写法 proxy_pass带协议，则upstream不带协议
upstream api { server 1.1.1.1:8080； server 2.2.2.2:8080; } server { location / { proxy_pass http://api; } }  upstream带协议，则proxy_pass不带协议
upstream api { server http://1.1.1.1:8080； server http://2.2.2.2:8080; } server { location / { proxy_pass api; } }  proxy传递URI注意事项 想要改变URI，则在proxy中配置URI
不想改变URI，则不再proxy中配置URI
server { server_name server location / { proxy_pass http://proxy; # proxy_pass不带URI，则传递原本请求的URI,即访问server/aaa代理为proxy/aaa } location /aaa { proxy_pass http://proxy; # proxy_pass不带URI，则传递URI，即访问server/aaa代理为proxy/aaa } location /aaa { proxy_pass http://proxy/bbb; # proxy_pass带URI，则替换原有URI，访问server/*全部代理为proxy/bbb } location /ccc { proxy_pass http://proxy/; # proxu_pass带URL，则替换原有URI，访问server/*全部代理为proxy/; } }  proxy_hide_header 隐藏头域信息</description>
    </item>
    
    <item>
      <title></title>
      <link>https://eiuapp.github.io/eiuapp-learn/nginx/ubuntu-install-nginx.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://eiuapp.github.io/eiuapp-learn/nginx/ubuntu-install-nginx.html</guid>
      <description>ubuntu 安装 nginx
env aliyun 上面的 nginx配置，放到本地
lan server
 os: ubuntu18.04 ip: 192.168.168.137  aliyun lcnx@iZwz95dxhc92qtibd4f399Z:/alidata/server/nginx/sbin$ ./nginx -V nginx version: nginx/1.6.0 built by gcc 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) TLS SNI support enabled configure arguments: --user=www --group=www --prefix=/alidata/server/nginx --with-http_stub_status_module --without-http-cache --with-http_ssl_module --with-http_gzip_static_module lcnx@iZwz95dxhc92qtibd4f399Z:/alidata/server/nginx/sbin$  lan server 所以，我的编译参数是
ubuntu@utuntu:~/lcnx/aliyun/env/nginx-1.16.0$ --prefix=/home/ubuntu/lcnx/aliyun/env/nginx-1.16.0 --with-http_stub_status_module --without-http-cache --with-http_ssl_module --with-http_gzip_static_module checking for OS + Linux 4.15.0-50-generic x86_64 checking for C compiler ... not found ./configure: error: C compiler cc is not found  所以要安装一下 gcc .</description>
    </item>
    
  </channel>
</rss>